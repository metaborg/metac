

// Start symbol
context-free start-symbols
Start

templates
Start = <<Program>>


// lexical syntax for INT, ID and layout
lexical syntax 
INT = [0-9]+
ID = [a-zA-Z][0-9a-zA-Z\_]*
LAYOUT = [\ \t\r\n]

ID = RestrictedKeywords {reject}
ID = RestrictedWordsBooleans {reject}
RestrictedKeywords = "abstract" | "continue" | "for" | "new" | "switch"
RestrictedKeywords = "assert" | "default" | "goto" | "package" | "synchronized"
RestrictedKeywords = "boolean" | "do" | "if" | "private" | "this" 
RestrictedKeywords = "break" | "double" | "implements" | "protected" | "throw"
RestrictedKeywords = "byte" | "else" | "import" | "public" | "throws"
RestrictedKeywords = "case" | "enum" | "instanceof" | "return" | "transient"
RestrictedKeywords = "catch" | "extends" | "int" | "short" | "try"
RestrictedKeywords = "char" | "final" | "interface" | "static" | "void"
RestrictedKeywords = "class" | "finally" | "long" | "strictfp" | "volatile"
RestrictedKeywords = "const" | "float" | "native" | "super" | "while"
RestrictedWordsBooleans = "true" | "false"

lexical restrictions
INT -/- [0-9]
ID -/- [a-zA-Z0-9\_]

context-free restrictions
LAYOUT? -/- [\ \t\r\n]


// comments (from Common.sdf from new spoofax project)
lexical syntax
[\*]                             								-> Asterisk
[\/]                             								-> Slash
(~[\*\/] | Asterisk | Slash)*									-> NestedCommentText
"/*" NestedCommentText NestedCommentRest "*/"					-> NestedComment			// }
NestedComment NestedCommentText	NestedCommentRest				-> NestedCommentRest		// }these two allow for nesting comments in eachother (with non nested comment) and inside next to eachother
																-> NestedCommentRest		// this is the stopcondition
NestedComment													-> LAYOUT
"//" ~[\n\r]* ([\n\r] | EOF)									-> LAYOUT
-> EOF
    
lexical restrictions
EOF -/- ~[]
Asterisk -/- [\/]
Slash -/- [\*]

context-free restrictions
LAYOUT? -/- [\/].[\/]
LAYOUT? -/- [\/].[\*]


// expressions
templates
IndexExp = <<Exp>>
Exp.Int = <<INT>>
Exp.Var = <<ID>>
Exp.Addition = <<Exp> + <Exp>> {left}
Exp.Subtraction = <<Exp> - <Exp>> {left}
Exp.Multiplication = <<Exp> * <Exp>> {left}
Exp.And = <<Exp> && <Exp>> {left}
Exp.Lessthan = <<Exp> \< <Exp>> {left}
Exp.ArrayField = <<Exp> [ <IndexExp> ]>
Exp.ArrayLength = <<Exp>.length>
Exp.True = <true>
Exp.False = <false>
Exp.This = <this>
Exp.Call = <<Exp>.<ID>(<Exp*;separator=", ">)>
Exp.NewIntArray = <new int [ <Exp> ]>
Exp.NewObject = <new <ID>()>
Exp.Not = <!<Exp>>
Exp = <(<Exp>)> {bracket}

template options
context-free priorities
{
	Exp "." ID "(" {Exp ","}* ")" -> Exp
	Exp "[" IndexExp "]"		  -> Exp
} >
{
	Exp "*" Exp                   -> Exp
} >
{ left:
	Exp "+" Exp                   -> Exp 
	Exp "-" Exp                   -> Exp 
} >
{
	Exp "<" Exp                   -> Exp 
} >
{
	Exp "&&" Exp                  -> Exp 
}


// statements
templates
Statement.Block = <
	{
		<Statement*>
	}
>
Statement.IfElse = <
	if (<Exp>)
		<Statement>
	else
		<Statement>
>
Statement.While = <
	while (<Exp>)
		<Statement>
>
Statement.Syso = <System . out . println ( <Exp> ) ;>
Statement.Assign = <<Var> = <Exp>;>
Statement.Assign = <<ArrayField> = <Exp>;>
Var.Var = <<ID>> // wrap lefthand var in var.
ArrayField.ArrayField = <<Exp> [ <Exp> ]> // lefthand array field


// types
templates
Type.IntArray = <int [ ] >
Type.Boolean = <boolean>
Type.Int = <int>
Type.Class = <<ID>>


// variable declarations
templates
VarDecl.VarDecl = <<Type> <ID> ;>


// method declarations
templates
MethodArg.MethodArg = <<Type> <ID>> 
MethodDecl.MethodDecl = <
	public <Type> <ID> (<MethodArg*;separator=", ">){
		<VarDecl*>
		<Statement*>
		return <Exp>;
	}
>

// class declarations
templates
ClassExtends.Extension = <extends <ID>>
ClassExtends.NoExtension = <>
ClassDecl.ClassDecl = <
	class <ID> <ClassExtends> {
		<VarDecl*>
		<MethodDecl*>
	}
>


// main class
templates
MainClass.MainClass = <
	class <ID> {
		public static void main (String [ ] <ID>){
			<Statement>
		}
	}
>


// program
templates
Program.Program = <
	<MainClass>
	<ClassDecl*>
>
