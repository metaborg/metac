module metaC/trans/generation/to-c

imports
	lib/analysis-library.generated
	lib/index-library.generated
	include/MetaC
	lib/c/c
	libstratego-gpp
	baseC/trans/desugaring/desugar
	BaseC/trans/desugaring/constructors


// === rewrite rules for BaseC to C99 === //
//TODO: move to different files
rules
	
	/**
	 * Default BaseC to C conversion
	 * TODO: enable (and debug)
	 */
	// to-c-def: c#(args) -> $[C-[c]]#(<map(to-c-top)>args)
	// 
	// to-c-top = to-c <+ to-c-def
	
	/**
	 * Constants & Literals & Identifiers
	 */
	to-c: Decimal(a) -> C-IntConst(a)
	to-c: String(a) -> C-StringLit([a])
	to-c: Identifier(a) -> C-Id(a)
	to-c: Var(a) -> <to-c>a
	
	
	/**
	 * Operators
	 */
	to-c: Assign() -> C-AssignEq()
	to-c: PlusAssign() -> C-AssignPlus()
	to-c: MinusAssign() -> C-AssignMin()
	to-c: MultiplyAssign() -> C-AssignMul()
	to-c: DivisionAssign() -> C-AssignDiv()
	to-c: ModuloAssign() -> C-AssignMod()
	to-c: BitwiseAndAssign() -> C-AssignAnd()
	to-c: BitwiseXorAssign() -> C-AssignExp()
	to-c: BitwiseOrAssign() -> C-AssignOr()
	to-c: BitshiftLeftAssign() -> C-AssignSL()
	to-c: BitshiftRightAssign() -> C-AssignSR()
	
	
	/**
	 * Expressions
	 */
	
	
	/**
	 * Types
	 */
	 to-c: BasicType("int32")->C-TypeSpec([], C-TypeId("int32_t"), [])
	 to-c: BasicType("int8")->C-TypeSpec([], C-TypeId("int8_t"), [])

	
	/**
	 * Declarations
	 */
	to-c: Declaration(type, name) -> 
				  	C-Declaration2(
				  		<to-c> type,
				  		C-IdDecl([], <to-c> name, None())
				  	)
								
	
	/**
	 * Expressions
	 */
	to-c: FunctionCall(a, b) -> C-FunCall(<to-c>a, <map(to-c)>b)
	to-c: BinExp(Plus(), exp1, exp2) 	-> C-Add(<to-c>exp1, <to-c>exp2)
	to-c: BinExp(Minus(), exp1, exp2) 	-> C-Subt(<to-c>exp1, <to-c>exp2)
	to-c: BinExp(Mul(), exp1, exp2)		-> C-Mul(<to-c>exp1, <to-c>exp2)
	to-c: BinExp(Div(), exp1, exp2)		-> C-Div(<to-c>exp1, <to-c>exp2)
	to-c: BinExp(Mod(), exp1, exp2) 	-> C-Mod(<to-c>exp1, <to-c>exp2)
	
	to-c: BinExp(LogicOr(), e1, e2)		-> C-LOr(<to-c>e1, <to-c>e2)
	to-c: BinExp(LogicAnd(), e1, e2)	-> C-LAnd(<to-c>e1, <to-c>e2)

	to-c: BinExp(BWOr(), e1, e2)		-> C-IncOr(<to-c>e1, <to-c>e2)
	to-c: BinExp(BWXor(), e1, e2)		-> C-ExOr(<to-c>e1, <to-c>e2)
	to-c: BinExp(BWAnd(), e1, e2)		-> C-And(<to-c>e1, <to-c>e2)
	to-c: BinExp(NotEq(), e1, e2)		-> C-NotEqual(<to-c>e1, <to-c>e2)
	to-c: BinExp(Eq(), e1, e2)			-> C-Equal(<to-c>e1, <to-c>e2)
	to-c: BinExp(GTE(), e1, e2)			-> C-Ge(<to-c>e1, <to-c>e2)
	to-c: BinExp(GT(), e1, e2)			-> C-Gt(<to-c>e1, <to-c>e2)
	to-c: BinExp(LTE(), e1, e2)			-> C-Le(<to-c>e1, <to-c>e2)
	to-c: BinExp(LT(), e1, e2)			-> C-Lt(<to-c>e1, <to-c>e2)
	to-c: BinExp(BitshiftR(), e1, e2)	-> C-ShiftRight(<to-c>e1, <to-c>e2)
	to-c: BinExp(BitshiftL(), e1, e2)	-> C-ShiftLeft(<to-c>e1, <to-c>e2)
 
 	to-c: UnExp(Size(), e1)				-> C-SizeofType(<to-c>e1)
 	to-c: UnExp(Addr(), e1)				-> C-Address(<to-c>e1)
 	to-c: UnExp(Deref(), e1)			-> C-Deref(<to-c>e1)
 	to-c: UnExp(BWCompl(), e1)			-> C-Tilde(<to-c>e1)
 	to-c: UnExp(LogicalNot(), e1)		-> C-Negation(<to-c>e1)
 	to-c: UnExp(Neg(), e1)				-> C-Negative(<to-c>e1)
 	to-c: UnExp(Pos(), e1)				-> C-Positive(<to-c>e1)
 	to-c: UnExp(DecPre(), e1)			-> C-PreIncr(<to-c>e1)
 	to-c: UnExp(IncPre(), e1)			-> C-PreDecr(<to-c>e1)
 	to-c: UnExp(DecPost(), e1)			-> C-PostDecr(<to-c>e1)
 	to-c: UnExp(IncPost(), e1)			-> C-PostIncr(<to-c>e1)
	

	
	/**
	 * Statements
	 */
	to-c: Return(a) -> C-Return(<to-c>a)
	to-c: Block(a) -> C-Compound([], <map(to-c)>a)
	to-c: Exp(a) -> C-Stat(<to-c>a)
	to-c: Assign(leftExp, assignOp, rightExp) ->
					C-Assign(
						<to-c> leftExp,
						<to-c> assignOp,
						<to-c> rightExp
					)
	to-c: IfElse(t1, t2, t3) -> C-IfElse(<to-c>t1, <to-c>t2, <to-c>t3)
	to-c: If(t1, t2) -> C-If(<to-c>t1, <to-c>t2)
	to-c: While(t1, t2) -> C-While(<to-c>t1, <to-c>t2)
	
	/**
	 * Structs
	 */
	to-c: Struct(_, name, fields) -> 
			C-Declaration2(
		      C-TypeSpec(
		        []
		      , C-Struct(<to-c>name, <map(to-c)>fields)
		      , []
		      )
		    , []
		    )
	to-c: FieldDecl(type, identifier) -> C-MemDecl(<to-c>type, [<to-c-field-decl>identifier])
	to-c-field-decl: Identifier(a) -> C-IdDecl([], C-Id(a), None())
	to-c: Declaration(a, b) -> 
			  C-Declaration2(
	            <to-c>a
	          , [ C-IdDecl([], <to-c>b, None()) ]
	          )
    to-c: StructType(a) -> C-TypeSpec([], C-StructId(<to-c>a), [])
	to-c: Field(a, b) -> C-Field(<to-c>a, <to-c>b)
	
	/**
	 * FunDef
	 */
	to-c: Param(type, name) ->
				  C-ParamDecl(
                    <to-c>type
                  , C-IdDecl([], <to-c>name, None())
                  )
    
    //TODO: do somewhat nicer for string[] argv
    to-c: Param(Array(BasicType("string"), None()), name) ->
    			  C-ParamDecl(
                    C-TypeSpec([], C-TypeId("int8_t"), [])
                  , C-IdDecl(
	                  [C-PointerOf([])]
	                , <to-c>name
	                , C-ArrayDecl(None(), None())
	                )
                  )
                  
    to-c: ParamList(a) -> C-ParamList(<map(to-c)>a)

	to-c: FunDef(_, returnType, name, params, statements) ->
				  C-FunDef(
				  	<to-c>returnType,
				  	C-IdDecl(
				      [],
				      <to-c>name,
				      <to-c>params
				    ),
				    <to-c>Block(statements)
				  )
			 


	/**
	 * Modules
	 */
	to-c: Module(Identifier(modulename), imports, contents) ->
			C-TranslationUnit(<conc>(
				[C-PpControl($[#include "[modulename].h"]),
				 C-PpControl($[#include <stdlib.h>])
				],
				<map(to-c)>contents))


