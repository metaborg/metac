module metaC/trans/generation/generate

imports
	lib/analysis-library.generated
	lib/analysis-library-internal.generated
	lib/editor-common.generated
	lib/index-library.generated
	libstratego-gpp
	libstratego-lib
	lib/c/c
	include/MetaC
	baseC/trans/desugaring/desugar
	baseC/trans/generation/to-c
	baseC/trans/generation/to-h
	baseC/trans/generation/to-makefile
	
signature constructors

Import : Identifier -> Import

// editor hooks
rules
	// debug builds
	editor-to-c-ast:
	    (selected, position, ast, path, project-path) -> (filename, result)
	    with
			filename := <guarantee-extension(|"c.aterm")> path;
			result   := <desugar-all;to-c>selected
	editor-to-c-ast-debug:
	    (selected, position, ast, path, project-path) -> (filename, result)
	    with
			filename := <guarantee-extension(|"c.aterm")> path;
			result   := <desugar-all;topdown(try(to-c))>selected
	
	// real builders
	editor-to-c:
	    (selected, position, ast, path, project-path) -> None()
	    with
			<basec-to-c> (selected, path)
	editor-to-h:
	    (selected, position, ast, path, project-path) -> None()
	    with
			<basec-to-h> (selected, path)
	editor-to-makefile:
	    (selected, position, ast, path, project-path) -> None()
	    with
			<basec-to-makefile> (selected, path)
	editor-compile:
	    (selected, position, ast, path, project-path) -> None()
	    with
	    	<base-c-to-compiledc> (selected, path, project-path)
	editor-execute:
		(selected, position, ast, path, project-path) -> None()
	    with
			<basec-execute> (selected, path, project-path)
	editor-and-imports-to-c:
	    (selected, position, ast, path, project-path) -> None()
	    with
			<basec-to-c-multiple> (selected, path, project-path)

// rewriting single files
rules
	basec-to-c:
	    (selected, path) -> None()
	    with
			fileName := <guarantee-extension(|"c")> path;
			result   := <desugar-all;to-c;pp-c-string>selected;
			<write-file> (fileName, result)
	basec-to-h:
	    (selected, path) -> None()
	    with
			fileName := <guarantee-extension(|"h")> path;
			result   := <desugar-all;to-h;pp-c-string>selected;
			<write-file> (fileName, result)
	basec-to-makefile:
	    (selected, path) -> None()
	    with
			fileName := $[[<dirname>path]/Makefile];
			result   := <desugar-all;to-makefile>selected;
			<write-file> (fileName, result)
	basec-to-c-h-makefile:
		(selected, path) -> None()
		with
			<basec-to-c> (selected, path);
			<basec-to-h> (selected, path);
			<basec-to-makefile> (selected, path)
	c-h-makefile-to-compiledc:
	    (selected, path, project-path) -> None()
	    with
			<try(call);debug> ("make", ["-C", $["[project-path]/[<dirname>path]"]]); //full path in quotes, in case of spaces
			<refresh-workspace-file><dirname>path
	base-c-to-compiledc:
		(selected, path, project-path) -> None()
		with
			<basec-to-c-h-makefile> (selected, path);
			<c-h-makefile-to-compiledc> (selected, path, project-path)
	compiledc-execute:
		(selected, path, project-path) -> None()
	    with
			exepath := $["[project-path]/[<dirname>path]/[<module-name>selected].exe"];
			<try(call)> (exepath, [])
	basec-execute:
		(selected, path, project-path) -> None()
		with
			<base-c-to-compiledc> (selected, path, project-path);
			<compiledc-execute>	(selected, path, project-path)


// rewrite multiple files
	basec-to-c-multiple:
	    (selected, path, project-path) -> None()
	    with
	    	desugaredAst := <desugar-all> selected;
	    	(analyzedAst, _) := <analyze-top(|<language>)> (desugaredAst, path, project-path);
	    	importIds := <import-ids>analyzedAst;
	    	importFiles := <filter(\Identifier(name) -> <index-lookup; index-get-files-of; map(Fst)> name\); concat; make-set> importIds;
			importAsts := <map(filename-to-ast)> importFiles;
			<debug>importAsts;
			<debug> "TODO: rewrite to c, h + make 'recursive'"
	    	//TODO: actually do compile these
	    	//TODO: make recursive (or not really recursive, because circular imports)

	id-to-name: Identifier(name) -> name
	id-to-name: Import(Identifier(name)) -> name
	all-module-names: Module(identifier, imports, _) -> <conc;map(id-to-name)>([identifier], imports)
	import-ids: Module(_, imports, _) -> <map(import-to-id)>imports
	import-to-id: Import(identifier) -> identifier
	
	filename-to-ast: file -> <index-get-value> AST(("MetaC", file), ())
			

// helper rules
rules
	// filewriter
	write-file: (fileName, content) -> (fileName, content)
		where
			<dirname;ensure-dir> fileName
		where
			fileDescriptor := <fopen> (fileName, "w");
			<fputs> (content, fileDescriptor);
			<fclose> fileDescriptor;
			<refresh-workspace-file> fileName
			
	ensure-dir: path -> path
		where
			<file-exists;filemode;isdir> path
	ensure-dir: path -> path
		where
			<not(file-exists;filemode;isdir)> path;
			<dirname;ensure-dir> path;
			<mkdir> path
	
	// c pretty printer (external)
	pp-c-string =
		ast2abox(|[<import-term(lib/c/c.pp.af)>]);
		box2text-string(|100)