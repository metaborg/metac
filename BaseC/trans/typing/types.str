module BaseC/trans/typing/types

imports
	include/metaC
	BaseC/trans/desugaring/constructors
	lib/nbl-library.generated
	libstratego-lib
	lib/editor-common.generated
	lib/index-library.generated
	lib/analysis-library.generated
	lib/analysis-library-internal.generated
	
signature constructors
	FunType : List(Type) * Type -> Type
	Int	  : type
	Flt	  : type
	Ch    : type
	Str   : type
	Ptr   : type
	
	Int8	: Type
	
rules
	/*type-of: _ -> BasicType("int8")
	where
		not(is-list)
	*/
	
	/*
	 *	Constants
	 */
	
	//checks if val is in interval [-(posLimit+1), posLimit]; posLimit >=0
	in-range(|posLimit): strVal -> "True"
	where
		val:= <try(string-to-int)> strVal;
		<leq> (val, posLimit);
		<geq> (val, <subti> (0, <addi> (posLimit, 1)))
	 
	type-of: Decimal(val) -> type
	where
		<in-range(|127)> val;			type:= BasicType("int8")	<+
		<in-range(|32767)> val;			type:= BasicType("int16")	<+
		<in-range(|2147483647)> val; 	type:= BasicType("int32")	<+
										type:= BasicType("int64")
	
	type-of: Hexadecimal(val)-> <type-of> Decimal(<hex-string-to-int> hexval)
	where
		hexval:= <ltrim-chars(?'0'); try(ltrim-chars(?'X')); try(ltrim-chars(?'x'))> val
			
	type-of: Octal(val)	-> <type-of> Decimal(<oct-string-to-int> val)
	
	type-of: Binary(val) -> <type-of> Decimal(<bin-string-to-int> binval)
	where
		binval:= <ltrim-chars(?'0'); ltrim-chars(?'b')> val
	
	generictype-of: BasicType("int8") -> Int()
	generictype-of: BasicType("int16") -> Int()
	generictype-of: BasicType("int32") -> Int()
	generictype-of: BasicType("int64") -> Int()
	
	supertype-of: BasicType("int8") -> BasicType("int16")
	supertype-of: BasicType("int16") -> BasicType("int32")
	supertype-of: BasicType("int32") -> BasicType("int64")
	
	
	subtype-of: (type, type) -> None()
	
	subtype-of: (type, super) -> None()
	where
		<eq> (<supertype-of> type, super)	<+
		<subtype-of> (<supertype-of> type, super)
		 
	 
	type-of: ParamList(l) -> <map(type-of)> l
	where
		<is-list> l
	
	type-of: Param(_, ident) -> <index-type-of> ident
	
	
	//type-of: Char(_)		-> Ch()
	//type-of: String(_)		-> Str()
	//type-of: Float(_)		-> Flt()

	// Unary oprations that are always integers
   	type-of : (Size(), _) 			-> Int()
   	type-of	: (LogicalNot(), _) 	-> Int()
   	
   	// Pointers get their own type
   	type-of : (Addr(), e) 			-> Pointer(<type-of> e)
   	
   	type-of: (Deref(), e) -> derefType
   	where
   		Pointer(derefType):= <type-of> e
   	 
   	// Other unary operations
   	type-of	:	(BWCompl(), e) 	-> <type-of> e
   	type-of	:	(Neg(), e) 		-> <type-of> e
   	type-of	:	(Pos(), e) 		-> <type-of> e
   	type-of	:	(DecPre(), e)	-> <type-of> e
   	type-of	:	(IncPre(), e) 	-> <type-of> e
   	type-of	:	(DecPost(), e) 	-> <type-of> e
   	type-of	:	(IncPost(), e) 	-> <type-of> e
   	
   	// Coercing for different types (implicit conversion)
   	
  	coerce: [type1, type1] -> type1
  	
  	coerce: [type1, type2] -> type2
  	where
  		<subtype-of> (type1, type2)
  	
  	coerce: [type1, type2] -> type1
  	where
  		<subtype-of> (type2, type1)
   	
   	coerce: [Ch(), Ch()]		-> Ch()
   	coerce: [Int(), Ch()] 		-> Int()
   	coerce: [Ch(), Int()] 		-> Int()
   	coerce: [Int(), Int()] 		-> Int()
   	coerce: [Flt(), Flt()] 		-> Flt()
   	coerce: [Int(), Flt()] 		-> Flt()
   	coerce: [Flt(), Int()] 		-> Flt()
   	coerce: [Ch(), Flt()] 		-> Flt()
   	coerce: [Flt(), Ch()] 		-> Flt()
   	//coerce: [Str(), Str()]		-> Str()	// should produce an error
   	
   	// Binary operations   	
   	type-of: (Plus(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (Minus(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (Div(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (Mod(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (Mul(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (BWAnd(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (BWOr(), e1, e2) 		-> <coerce> [e1,e2]
   	type-of: (BWXor(), e1, e2) 		-> <coerce> [e1,e2]	
    type-of: (BitshiftR(), e1, e2) 	-> <coerce> [e1,e2]
   	type-of: (BitshiftL(), e1, e2) 	-> <coerce> [e1,e2]
   	
   	// Types of logical operations are always integers
   	type-of: (LogicOr(), e1, e2) 	-> Int()
   	type-of: (LogicAnd(), e1, e2) 	-> Int()
   	type-of: (Eq(), e1, e2) 		-> Int()
   	type-of: (NotEq(), e1, e2) 		-> Int()
   	type-of: (GTE(), e1, e2) 		-> Int()
   	type-of: (GT(), e1, e2) 		-> Int()
   	type-of: (LTE(), e1, e2) 		-> Int()
   	type-of: (LT(), e1, e2) 		-> Int()
   	
   	// Types of expressions
   	type-of:	UnExp(op, e) 		-> <type-of> (op, <type-of> e)
   	type-of: 	BinExp(op, e1, e2) 	-> <type-of> (op, <type-of> e1, <type-of> e2)
   	
   	// operators
   	
   	type-of: Plus() -> (Int(), Int(), Int())
   	type-of: Minus() -> (Int(), Int(), Int())
   	type-of: Mul() -> (Int(), Int(), Int())
   	type-of: Div() -> (Int(), Int(), Int())
   	type-of: Mod() -> (Int(), Int(), Int())
   	type-of: BWAnd() -> (Int(), Int(), Int())
   	type-of: BWOr() -> (Int(), Int(), Int())
   	type-of: BWXor() -> (Int(), Int(), Int())	
    type-of: BitshiftR() -> (Int(), Int(), Int())
   	type-of: BitshiftL() -> (Int(), Int(), Int())
   	
   	type-of: Neg() -> (Int(), Int())
   	
   	
   	//struct fields
   	type-of: Field(_, Identifier(fieldId)) -> <index-type-of> fieldId
   	//type-of: FieldViaPointer()
   	
   	
   	
   		
   	index-type-of:
  		x -> <index-get-data(|Type())> Def(uri)
  	where
  		uri := <index-uri> x
   	
   	type-of: Var(Identifier(x)) -> t
   	where
   		//debug(!"1: "); 
   		//uri := <index-uri; debug(!"URI: ")> x;
   		//t := <index-get-data(|Type()); debug(!"Type: ")> Def(uri)
   		t := <index-type-of> x
   			
   	//type-of: Field(x,y) -> <nbl-get-type> y
   	
   	//dummy: remove
   	type-of: (exp, _) -> <type-of> exp
   	