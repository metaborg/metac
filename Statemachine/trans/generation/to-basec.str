module to-basec

imports
		include/MetaC
		lib/nabl/-
		libstratego-lib
		lib/editor-common.generated
		lib/index/-
		lib/analysis/-
		lib/types/-
		lib/c/C
		libstratego-gpp
		Statemachine/trans/statemachine-names
		BaseC/trans/analysis/desugar/-
		BaseC/trans/generation/to-c
		trans/builders/generate

signature constructors
	EntryStatementsPlaceholder: ID -> StatementPlaceholder

rules
	
	to-basec-all(|path): ast -> outAst
	where
		//(basecAST, _):= <topdown(try(to-basec-devel);try(flatten-list))> ast
		outAst := <topdown(try(to-basec);try(flatten-list))> ast
		//smPath:= $[[<remove-extension> path]__sm.mc];
		//filename := <guarantee-extension(|"h")> smPath;
		//result   := <desugar-all;to-c;pp-c-string> basecAST;
		//<write-file> (filename, result)
	
	
	//TODO - expand names on the basec-ast?
	to-basec: Statemachine(name, initial, components*) -> [headerAST, executeFunction]// [headerAST, initFunction, executeFunction] //(headerModule, executeFunction, initFunction)		//TODO: change to generate header file(including initFunction?) and output only executeFunction 
	where
		moduleName := <get-module-name> name
      ; <collect-components> components* => (states, events, vars)
	  ; <generate-header(|moduleName, name)> (states, events, vars) => headerAST
	  ; <generate-function(|moduleName, name)> states => executeFunction
		//<generate-sm-basec-init(|moduleName, name, initial)> vars_out => initFunction
	
	get-module-name: smName -> parent
	where
		parent:= <nabl-uri; nabl-uri-path; filter(?ID(NablNsModule(), _, _)); Hd; nabl-segment-name> smName
	
	get-statemachine-name: element -> statemachine
	where
		statemachine:= <nabl-uri; nabl-uri-path; filter(?ID(NablNsStatemachine(), _, _)); Hd; nabl-segment-name> element
		
	collect-components: componentList* -> (states, events, vars)
	where
		not(<eq> (0, <length> componentList*));	 	
	 	states:= <collect-states; map(expand-name); debug(!"states: ")> componentList*;
	 	events:= <collect-events; map(expand-name); debug(!"events: ")> componentList*;
	 	vars:= <collect-vars> componentList*					
	
	collect-states = filter(?StateMachineState(_, _))
	
	collect-events = filter(?StateMachineInEvent(_, _) <+ ?StateMachineOutEvent(_, _, _))

	collect-vars = filter(?StateMachineVarDecl(_, _, _, _))
	
	expand-name: StateMachineInEvent(name, block) -> StateMachineInEvent($[[<get-statemachine-name>name]__event_[name]], block)
	expand-name: StateMachineOutEvent(name, param, binding) -> StateMachineOutEvent($[[<get-statemachine-name>name]__event_[name]], param, binding)
	expand-name: StateMachineState(name, block) -> StateMachineState($[[<get-statemachine-name>name]__state_[name]], block)
	expand-name: name -> fname
	where
		is-statemachine-state;
		fname:= $[[<get-statemachine-name> name]__state_[name]]
	
	generate-header(|moduleID, smID): (states, events, vars) -> [event-enum, state-enum, var-struct]//Module($[[moduleName]Header], None(), headerAST)          //add module imports
	where
		event-enum:= <generate-enum(|moduleID, smID)> ("_sm_events_", events);		
		state-enum:= <generate-enum(|moduleID, smID)> ("_sm_states_", states);
		var-struct:= <generate-struct(|moduleID, smID)> ("_sm_data_", vars);
		smFunctionPrototype := []										//TODO if generating sm header
		
	generate-enum(|moduleID, smID): (name, componentList) -> Enum(Exported(), Identifier($[[moduleID][name][smID]]), enumList)
	where
		enumList:= <mapconcat(try(generate-enumItem))> componentList
	
	generate-enumItem: StateMachineInEvent(event_name, _) -> [EnumItem(Identifier(event_name))]
	
	generate-enumItem: StateMachineOutEvent(_, _, _) -> []
	
	generate-enumItem: StateMachineState(state_name, _) -> [EnumItem(Identifier(state_name))]
	
	generate-struct(|moduleID, smID): (name, componentList) -> Struct(Exported(), Identifier($[[moduleID][name][smID]]), structBody)
	where
		structList:= <map(try(generate-structItem))> componentList;
		currentState:= FieldDecl(Type([], EnumType(Identifier($[[moduleID]_sm_states_[smID]]))), Identifier("__currentState"));
		structBody:= [currentState | structList]
		
	generate-structItem: StateMachineVarDecl(_, type, name, _) -> element
	where
		element:= FieldDecl(type, name)
		
	generate-function(|moduleID, smID): statesList -> smFunctionAST
	where
		name:= $[[moduleID]_sm_execute_[smID]];
		params := <generate-params> ($[[moduleID]_sm_data_[smID]], $[[moduleID]_sm_events_[smID]]);
		stateCaseList:= <map(generate-state-case); insert-entryBlocks(|statesList)> statesList;
		
		stateSwitch:= Switch(FieldViaPointer(Var(Identifier("instance")), Identifier("__currentState")), Block(stateCaseList));				
		smFunctionBlock := [stateSwitch];			
		smFunctionAST := FunDef(None(), Type([], BasicType("void")), Identifier(name), ParamList(params), smFunctionBlock)							
	
	insert-entryBlocks(|stateList): caseStatements -> statements
	where
		statements:= <topdown(try(insert-entryBlock(|stateList)))> caseStatements
	
	insert-entryBlock(|stateList): EntryStatementsPlaceholder(name) -> basecStm
	where
		statements:= <filter(\StateMachineState(name, body)->body\); flatten-list; filter(\StateEntry(Block(stm))->stm\)> stateList;
		basecStm:= <topdown(try(to-basec(|None()))); debug(!"stmList: ")> statements
	
	generate-params: (smData, smEvents) -> [instance, event, arguments] 
	where
		instance:= Param(Type([], Pointer(StructType(Identifier(smData)))), Identifier("instance"));			
		event:= Param(Type([], EnumType(Identifier(smEvents))), Identifier("event"));
		arguments:= Param(Type([], Pointer(Type([], Pointer(Type([], BasicType("void")))))), Identifier("arguments"))
	
	generate-state-case: StateMachineState(stateID, stateBody*) -> stateCaseStatement
	where
		caseStatements:= <generate-case> stateBody*;
		eventSwitch:= Switch(Var(Identifier("event")), Block(caseStatements));
		stateCaseStatement := Case(Var(Identifier(stateID)), Block([eventSwitch, Break()]))		
	
	generate-case: stateBody* -> eventCaseList
	where
		transitions:= <filter(?StateTransition(_, _, _, _))> stateBody*;
		exitStatements:= <collect(\StateExit(Block(stmList))->stmList\); try(flatten-list)> stateBody*;
		eventNames:= <collect(\InEventRef(name)->name\)> transitions;
		eventCaseList:= <map(generate-event-case(|transitions, exitStatements))> eventNames
	
	generate-event-case(|transitions, exitStatements): eventName -> [Case(Var(Identifier(eventName)), Block([ifStatements, Break()]))]
	 where
	 	eventTransitions:= <filter(?StateTransition(InEventRef(eventName), _, _, _))> transitions;
	 	ifStatements:= <map(generate-if(|exitStatements))> eventTransitions
	 	
	generate-if(|exitStatements*): StateTransition(InEventRef(name), condition, StateRef(endState), block) -> ifStatement
	where
	 	conditionStatement:= <topdown(try(to-basec(|name)))>condition;
	 	stateStatements*:= <topdown(try(to-basec(|name)))> [exitStatements*, block];
	 	switchState:= Exp(Some(Assign(FieldViaPointer(Var(Identifier("instance")),Identifier("__currentState")), Assign(), Var(Identifier(endState)))));
		return:= Return(Decimal(-1));
	 	ifStatement:= <generate-if> (conditionStatement, [stateStatements*, switchState, EntryStatementsPlaceholder(<expand-name> endState), return])
	
	generate-if: (condition, body) -> statement
	where
		if None():= condition
		then
			statement:= If(True(), Block(body))
		else
			statement:= If(condition, Block(body))
		end
	
	to-basec(|event): Var(Identifier(name)) -> Brackets(Dereference(TypeConversion(Type([], Pointer(paramType)), ArrayField(Var(Identifier("arguments")), Decimal(index)))))//cast expression:   (*((int8_t*)((arguments[0]))));
	where
		<is-event-param> name;
		paramType:= <get-type> name;
		index := <subt> (<get-paramIndex> name, 1)
	
	to-basec(|event): Var(Identifier(name)) -> FieldViaPointer(Var(Identifier("instance")), Identifier(name))					//strip-annos?
	where
		<is-statemachine-var> name
		
	to-basec(|event): Block(statements) -> statements
	to-basec(|event): None() -> []
	
	is-namespace(|s) = nabl-uri; nabl-uri-namespace; ?s
	parent-is-namespace(|s) = nabl-uri; nabl-uri-parent; nabl-uri-namespace; ?s
		
	is-statemachine-var: name -> None()
	where
		is-namespace(|NablNsVariable());
		<parent-is-namespace(|NablNsStatemachine())> name
	
	is-event-param: name -> None()
	where
		is-namespace(|NablNsVariable());
		<parent-is-namespace(|NablNsInEvent())> name
	
	is-statemachine-state = nabl-uri; nabl-uri-namespace; ?NablNsState()
	
/*	get-sm-stateExit-statements(|stateName): StateMachineState(stateID, stateBody) -> statementBlock
	where
		<eq> (stateName, stateID);
		StateExit(stmBlock) := <fetch-elem(get-stateExit-block)> stateBody;
		statementBlock:= [<stm-to-basec> stmBlock] <+
		statementBlock:= []		
	
	get-sm-stateEntry-statements(|stateName): StateMachineState(stateID, stateBody) -> statementBlock
	where
		<eq> (stateName, stateID);
		//get stateEntry statements
		StateEntry(stmBlock) := <fetch-elem(get-stateEntry-block)> stateBody; 
		statementBlock:= [<stm-to-basec> stmBlock] <+
		statementBlock:= []
		
	
	get-stateEntry-block: StateEntry(statementBlock) -> StateEntry(statementBlock)
	
	get-stateExit-block: StateExit(statementBlock) -> StateExit(statementBlock)
	
	get-transitionStatements: None() -> []
	
	get-transitionStatements: Some(StatementBlock) -> [basecBlock]
	where
		basecBlock := <stm-to-basec> StatementBlock
	
	get-transition-conditionStatement: Some(statement) -> basecStatement
	where
		basecStatement := <stm-to-basec;debug(!"here: ")> statement
		//basecStatement := statement
	
	get-transition-conditionStatement: None() -> []
	
	generate-sm-basec-ifStatement: (None(), statementList) -> Block(statementList)
	
	generate-sm-basec-ifStatement: (condition, statementList) ->  If(condition, Block(statementList))
	where 
		not(<eq> (condition, None()))
		
	stm-to-basec: stmBlock -> basecBlock
	where
		basecBlock:= <topdown(try(to-basec(|None())))> stmBlock
	
	unbox-block: Block(statementList) -> statementList
	unbox-block: None() -> []											 
		
	*/