module Statemachine-mapping

imports MetaC
imports include/MetaC
		lib/nbl-library.generated
		libstratego-lib
		lib/editor-common.generated
		lib/index-library.generated
		lib/analysis-library.generated
		lib/analysis-library-internal.generated
		Statemachine/trans/statemachine-names
	
rules
	
	to-basec-all = topdown(try(to-basec);try(flatten-list))
	
	//to-basec: [Statemachine(ident, init, comp)] -> <to-basec> Statemachine(ident, init, comp)
	
	get-module: smName -> parent
	where
		[_, _, parent | tail]:= <index-uri> smName
	
	to-basec: Statemachine(Identifier(statemachineID), _, components*) -> initFunction //(headerModule, executeFunction, initFunction)		//TODO: change to generate header file(including initFunction?) and output only executeFunction 
	where
		moduleName := <get-module> statemachineID;
		<collect-components(|statemachineID)> components* => (states_out, events_out, vars_out)
		;<generate-statemachine-header(|moduleName, statemachineID)> (states_out, events_out, vars_out) => headerModule;
		<generate-sm-basec-function(|moduleName, statemachineID)> states_out => executeFunction;
		<generate-sm-basec-init(|moduleName, statemachineID)> vars_out => initFunction
		
	collect-components(|statemachineID): componentList* -> (states, events, vars)
	where
		not(<eq> (0, <length> componentList*));	 	
	 	states:= <collect-states(|statemachineID)> componentList*;
	 	events:= <collect-events(|statemachineID)> componentList*;
	 	vars:= <collect-vars> componentList*
	
	
	collect-states(|statemachineID): componentList* -> states
	where
		not(<eq> (0, <length> componentList*));
		states:= <mapconcat(try(collect-state(|statemachineID)))>
		
	collect-state(|statemachineID): component -> out//<debug(!"state: ")>out		
	where
		newComponent:= <expand-state-name(|statemachineID)> component;
		out:= [newComponent] <+
		out:= []
	
	collect-events(|statemachineID): componentList* -> events
	where
		not(<eq> (0, <length> componentList*));
		events:= <mapconcat(try(collect-event(|statemachineID)))>
		
	collect-event(|statemachineID): component -> out//<debug(!"event: ")>out
	where
		newComponent:= <expand-event-name(|statemachineID)> component;
		out:= [newComponent] <+
		out:= []
		
	collect-vars: componentList* -> vars
	where
		not(<eq> (0, <length> componentList*));
		vars:= <mapconcat(try(collect-var))>
		
	collect-var: component -> out//<debug(!"var: ")> out
	where
		StateMachineVarDecl(_, _, _, _):= component;
		out:= [component] <+
		out:= []
	
	generate-statemachine-header(|moduleName, statemachineID ): (states, events, vars) -> Module($[[moduleName]Header], None(), headerAST)          //add module imports
	where
		events_enumID:= $[[moduleName]_sm_events_[statemachineID]];
		states_enumID:= $[[moduleName]_sm_states_[statemachineID]];
		vars_structID:= $[[moduleName]_sm_data_[statemachineID]];
		events_enum:= <generate-sm-basec-enum(|statemachineID)> (events_enumID, events);		
		states_enum:= <generate-sm-basec-enum(|statemachineID)> (states_enumID, states);
		vars_struct:= <generate-sm-basec-struct(|statemachineID)> (vars_structID, vars);
		
		Struct(exported, _, structList):= vars_struct;
		structList2:= [FieldDecl(Identifier(states_enumID), Identifier("__currentState"))|structList];												//need structType(states_enumID)?
		vars_struct2:= Struct(exported, Identifier(vars_structID), structList2);
		
		smFunctionPrototype := [];										//TODO
		headerAST:= [events_enum, states_enum, vars_struct2]
	
		
	generate-sm-basec-enum(|statemachineID): (enumID, componentList) -> Enum(Exported(), Identifier(enumID), enumList)
	where
		exported := "exported";
		enumList:= <mapconcat(try(generate-sm-basec-enumElement(|statemachineID)))> componentList
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineInEvent(event_name, _) -> [EnumItem(event_name)]
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineOutEvent(_, _, _) -> []
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineState(state_name, _) -> [EnumItem(state_name)]
	
	generate-sm-basec-struct(|statemachineID): (structID, componentList) -> Struct(Exported(), Identifier(structID), structList)
	where
		structList:= <mapconcat(try(generate-sm-basec-structElement(|statemachineID)))> componentList
		
	generate-sm-basec-structElement(|statemachineID): StateMachineVarDecl(_, type, name, _) -> [element]
	where
		element:= FieldDecl(type, [name])
		//////******
		
	generate-sm-basec-function(|moduleName, statemachineID): statesList -> smFunctionAST
	where
		functionName:= $[[moduleName]_sm_execute_[statemachineID]];
		stateCaseList:= <map(generate-sm-basec-stateCase(|statemachineID, statesList))> statesList;
		stateSwitch:= Switch(FieldViaPointer(Var(Identifier("instance")), Identifier("__currentState")), Block(stateCaseList));				
		//smFunctionBlock:= Block([stateSwitch]);
		smFunctionBlock := [stateSwitch];
		smFunctionParams := <generate-sm-basec-function-params> (moduleName, statemachineID);			
		smFunctionAST := FunDef(None(), BasicType("int8"), Identifier(functionName), ParamList(smFunctionParams), smFunctionBlock)									//TODO change type to void
	
	generate-sm-basec-function-params: (moduleName, statemachineID) -> paramList 
	where
		//TODO change to params pointers
		instance:= Param(Identifier($[[moduleName]_sm_data_[statemachineID]]), Identifier("instance"));			//change to data_counter *
		event:= Param(Identifier($[[moduleName]_sm_events_[statemachineID]]), Identifier("event"));
		arguments:= Param(BasicType("int8"), Identifier("arguments"));					//change to void**
		paramList:= [instance, event, arguments]
	
	generate-sm-basec-stateCase(|statemachineID, statesList): StateMachineState(stateID, stateBody*) -> stateCaseStatement
	where
		//case stateID
		//switch event
		eventCaseList:= <mapconcat(generate-sm-basec-eventCase(|statemachineID, statesList, stateID))> stateBody*;
		eventSwitch:= Switch(Var(Identifier("event")), Block(eventCaseList));						
		
		stateCaseStatement := Case(Var(Identifier(stateID)), Block([eventSwitch, Break()]))			
	
	
	/*	case eventID
	 *	generate if condition
	 *	generate exit from current state
	 *	generate transitionActions
	 *	generate switchState
	 *	generate entry statements for targetState
	 *	return;
	*/
	//TODO refactor: remove unbox mess
	generate-sm-basec-eventCase(|statemachineID, statesList, currentStateID): StateTransition(Identifier(eventID), condition, Identifier(targetStateName), transitionActions) -> [eventCaseStatement]
	where
	 	targetStateID := <expand-state-nameString(|statemachineID)> targetStateName;
	 	//conditionStatement:= <debug(!"beforeTRANS:");get-transition-conditionStatement> condition;										//generate if condition
	 	conditionStatement:= <debug(!"condition: ")>condition;
	 	exitStatements* := <mapconcat(try(get-sm-stateExit-statements(|currentStateID)))> statesList;			//generate exit from current state
		//transitionStatements*:= <debug(!"beforeTRANS:");get-transitionStatements;debug(!"transitionSTM:")> transitionActions;									//generate transitionActions: 
	 	transitionStatements* := [transitionActions];
	 	switchStateStatement*:= [Block([Exp(Some(Assign(FieldViaPointer(Var(Identifier("instance")),Identifier("__currentState")), Assign(), Var(Identifier(targetStateID)))))])];		//generate switchState
	 	entryStatements*:= <mapconcat(try(get-sm-stateEntry-statements(|targetStateID)))> statesList;			//generate entry statements for targetState
	 	//basecReturnStatement*:= [Block([Return(None())])];
	 	basecReturnStatement*:= [Block([Return(Decimal(-1))])];

	 	ifBody:= <mapconcat(try(unbox-block))> [exitStatements*, transitionStatements*, switchStateStatement*, entryStatements*, basecReturnStatement*];
	 	ifStatement:= <generate-sm-basec-ifStatement> (conditionStatement, ifBody);
	 	
	 	eventCaseStatement:= Case(Var(Identifier(<expand-event-nameString(|statemachineID)>eventID)), Block([ifStatement, Break()]))
		
	generate-sm-basec-eventCase(|statemachineID, statesList, currentStateID): StateEntry(_) -> []
	
	generate-sm-basec-eventCase(|statemachineID, statesList, currentStateID): StateExit(_) -> []
	
	
	get-sm-stateExit-statements(|stateName): StateMachineState(stateID, stateBody) -> statementBlock
	where
		<eq> (stateName, stateID);
		StateExit(stmBlock) := <fetch-elem(get-stateExit-block)> stateBody;
		statementBlock:= [<stm-to-basec> stmBlock] <+
		statementBlock:= []		
	
	get-sm-stateEntry-statements(|stateName): StateMachineState(stateID, stateBody) -> statementBlock
	where
		<eq> (stateName, stateID);
		//get stateEntry statements
		StateEntry(stmBlock) := <fetch-elem(get-stateEntry-block)> stateBody; 
		statementBlock:= [<stm-to-basec> stmBlock] <+
		statementBlock:= []
		
	
	get-stateEntry-block: StateEntry(statementBlock) -> StateEntry(statementBlock)
	
	get-stateExit-block: StateExit(statementBlock) -> StateExit(statementBlock)
	
	get-transitionStatements: None() -> []
	
	get-transitionStatements: Some(StatementBlock) -> [basecBlock]
	where
		basecBlock := <stm-to-basec> StatementBlock
	
	get-transition-conditionStatement: Some(statement) -> basecStatement
	where
		basecStatement := <stm-to-basec;debug(!"here: ")> statement
		//basecStatement := statement
	
	get-transition-conditionStatement: None() -> []
	
	generate-sm-basec-ifStatement: (None(), statementList) -> Block(statementList)
	
	generate-sm-basec-ifStatement: (condition, statementList) ->  If(condition, Block(statementList))
	where 
		not(<eq> (condition, None()))
	
	expand-event-name(|statemachineID): StateMachineInEvent(Identifier(eventID), block) -> StateMachineInEvent(<expand-event-nameString(|statemachineID)> eventID, block)
		
	expand-event-name(|statemachineID): StateMachineOutEvent(Identifier(eventID), param, binding) -> StateMachineOutEvent(<expand-event-nameString(|statemachineID)> eventID, param, binding)
		
	expand-event-nameString(|statemachineID): eventID -> $[[statemachineID]__event_[eventID]]						//refactor	
			 
	expand-state-name(|statemachineID): StateMachineState(Identifier(stateID), block) -> StateMachineState(<expand-state-nameString(|statemachineID)> stateID, block)
	
	expand-state-nameString(|statemachineID): stateID -> $[[statemachineID]__state_[stateID]]						
	
	//TODO to-basec statements and expressions
	
	stm-to-basec: anything -> anything
	
	unbox-block: Block(statementList) -> statementList
	unbox-block: None() -> []											
	 
	//TODO: StateMachineInit(id) -> FunCall(id)     - need namebinding?     - same for smtrigger(id, event(param) ) and smIsInState(statemachineID, stateID)
	
	//TODO to-basec varRef - need namebinding: variables defined in statemechine desugar to instance->varname; global variables desugar to varname
	//										   event params desugar to arguments[index] in condition; statemachine variables desugar to varname in condition; global variables desugar to global varname
	
	generate-sm-basec-init(|moduleName, statemachineID): varList -> initFunction
	where
		initBlock:=<map(generate-sm-basec-initStm)> varList;
		functionName:= Identifier($[[moduleName]_sm_init_[statemachineID]]);
		paramList:= [Param(Identifier($[[moduleName]_sm_data_[statemachineID]]), Identifier("instance"))];											//TODO change type to pointer
		initFunction:= FunDef(None(), BasicType("int8"), functionName, ParamList(paramList), initBlock)													//TODO change type to void
		
	generate-sm-basec-initStm: StateMachineVarDecl(_, _, varName, initValue) -> initStatement
	where
		initStatement:= Exp(Some(Assign(FieldViaPointer(Var(Identifier("instance")), varName), Assign(), initValue))) 
		
	//TODO send?
	