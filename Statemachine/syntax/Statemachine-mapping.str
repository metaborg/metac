module Statemachine-mapping

imports MetaC
imports Statemachine/syntax/Statemachine

rules
	
	to-basec(|moduleName): Statemachine(statemachineID, _, components*) -> headerAST//(statemachine_function, header)
	//to-basec(|moduleName): whatever -> whatever
	where
		//statemachine_function:= 0;
		<collect-components> components* => (states_out, events_out, vars_out);
		<error> [states_out];
		<error> [events_out];
		<error> [vars_out];
		<generate-statemachine-header(|moduleName, statemachineID)> (states_out, events_out, vars_out) => headerAST
		
		//mbeddr statemachine events enum name: __moduleName_sm_events_statemachineID
		
		
	collect-components: componentList* -> (states, events, vars)
	where
		not(<eq> (0, <length> componentList*));	 	
	 	states:= <collect-states> componentList*;
	 	events:= <collect-events> componentList*;
	 	vars:= <collect-vars> componentList*
	
	
	collect-states: componentList* -> states
	where
		not(<eq> (0, <length> componentList*));
		states:= <mapconcat(try(collect-state))>
		
	collect-state: component -> out		
	where
		StateMachineState(_, _) := component;
		out:= [component] <+
		out:= []
	
	collect-events: componentList* -> events
	where
		not(<eq> (0, <length> componentList*));
		events:= <mapconcat(try(collect-event))>
		
	collect-event: component -> out
	where
		StateMachineInEvent(_, _) := component;
		out:= [component] <+
		StateMachineOutEvent(_, _, _) := component;
		out:= [component] <+
		out:= []
		
	collect-vars: componentList* -> vars
	where
		not(<eq> (0, <length> componentList*));
		vars:= <mapconcat(try(collect-var))>
		
	collect-var: component -> out
	where
		StateMachineVarDecl(_, _, _, _):= component;
		out:= [component] <+
		out:= []
	
	generate-statemachine-header(|moduleName, statemachineID ): (states, events, vars) -> headerAST
	where
		events_enumID:= <concat-strings> [moduleName, "_sm_events_", statemachineID];
		events_enum:= <generate-sm-basec-enum(|statemachineID)> (events_enumID, events);
		states_enumID:= <concat-strings> [moduleName, "_sm_states_", statemachineID];
		states_enum:= <generate-sm-basec-enum(|statemachineID)> (states_enumID, states);
		vars_structID:= <concat-strings> [moduleName, "_sm_data_", statemachineID];
		vars_struct:= <generate-sm-basec-struct(|statemachineID)> (vars_structID, vars);
		Struct(_, ):=
		headerAST:= [events_enum, states_enum, vars_struct];
		<error> [events_enum];
		<error> [states_enum];
		<error> [vars_struct]
		
	generate-sm-basec-enum(|statemachineID): (enumID, componentList) -> Enum(enumID, enumList)
	where
		enumList:= <mapconcat(try(generate-sm-basec-enumElement(|statemachineID)))> componentList
		//<error> [enumList]
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineInEvent(event_name, _) -> [EnumElement(name)]
	where
		name:= <concat-strings> [statemachineID, "__event_", event_name]
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineOutEvent(_, _, _) -> []
	
	generate-sm-basec-enumElement(|statemachineID): StateMachineState(state_name, _) -> [name]
	where
		name:= <concat-strings> [statemachineID, "__state_", state_name]
	
	
	generate-sm-basec-struct(|statemachineID): (structID, componentList) -> Struct(structID, structList)
	where
		structList:= <mapconcat(try(generate-sm-basec-structElement(|statemachineID)))> componentList
		
	generate-sm-basec-structElement(|statemachineID): StateMachineVarDecl(_, type, name, _) -> [element]
	where
		element:= StructElement(type, name)
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
									
		